import { createSlice, PayloadAction, SerializedError } from '@reduxjs/toolkit';

import SliceStatus from '../../models/SliceStatus';
import Tracker from '../../models/Tracker';
import TrackerEntry from '../../models/TrackerEntry';
import { v4 } from 'uuid';

// ===== State

export interface TrackersState {
  error: SerializedError;
  status: SliceStatus;
  trackers?: Tracker[];
}

const initialState: TrackersState = {
  error: {},
  status: SliceStatus.idle,
  trackers: undefined
};

// ===== Thunk

// export const fetchAllTrackers = createAsyncThunk('trackers/fetchAllTrackers', async () => {
//   const response = await TrackersActions.fetchAll();
//   return response.data;
// });

// ===== Reducers

export const trackersSlice = createSlice({
  name: 'trackers',
  initialState,
  reducers: {
    createTracker: (state, action: PayloadAction<Tracker>) => {
      if (state.trackers) {
        state.trackers.unshift(action.payload);
      } else {
        state.trackers = [action.payload];
      }
    },
    completelyValidate: (state, action: PayloadAction<string>) => {
      if (state.trackers) {
        const trackerFound = state.trackers.find((t) => t.id === action.payload);
        if (trackerFound) {
          trackerFound.entries.push({
            id: v4(),
            completions: trackerFound.requiredCompletions,
            date: new Date().toString(),
            trackerId: trackerFound.id
          } as TrackerEntry);
        }
      }
      return state;
    }
  }
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  // extraReducers: (builder) => {})
});

export const { createTracker, completelyValidate } = trackersSlice.actions;
export default trackersSlice.reducer;
